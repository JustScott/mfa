#!/home/administrator/Git/Local/mfa/venv/bin/python
#
# mfa - part of the mfa project
# Copyright (C) 2023, Scott Wyman, development@scottwyman.me
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU Affero General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU Affero General Public License for more details.
#
# You should have received a copy of the GNU Affero General Public License
# along with this program.  If not, see <https://www.gnu.org/licenses/>.


import typer
import json
import generators
import keyring_storage
import seed_file
from getpass import getpass
import shutil

__author__ = "Scott Wyman (development@scottwyman.me)"

__license__ = "GPLv3"

__date__ = "July 26, 2023"

__all__ = [""]

__doc__ = (
'''
A simple TOTP MFA CLI authenticator
'''
)


class SeedDict(dict):
    '''
    Instances operate as a dictionary with extra methods for
    checking keys and values, encrypting and writing the dictionary
    content to an aes file, etc.

    Attributes:
        self.file_name (str):
            The file name/file path of the encrypted seed file 
    '''
    def __init__(self, file_name: str="/home/administrator/mfa_secrets.aes"):
        '''
        The initialization handles decrypting the content of the seed file
        with the password stored in the keychain. It prompts the user for
        the password if it can't be found in the keychain.

        Args:
            file_name (str, *optional):
                DEFAULT /home/administrator/mfa_secrets.aes

                The file name/file path of the encrypted seed file.
                The file name should have a suffix of '.aes', otherwise
                unexpected errors can happen during import and export.
        '''
        self.file_name = file_name
        
        # Decrypt and add the contents of the seed_file to this
        #  instances dict
        #
        # Get the password from the keyring if it exists
        password = keyring_storage.get_keyring_password()
        seed_file_content = None
        while True:
            # If there isn't a password in the keyring, or the
            #  wrong decryption password was used
            if not password or seed_file_content == False:
                # Ask the user for a password
                try:
                    password = getpass("Enter the seed file's decryption key: ")
                except KeyboardInterrupt: # except a keyboard interrupt
                    print('\nCancelled')
                    quit(1)
            try:
                # Decrypt the seed file
                seed_file_content = seed_file.decrypt_from_file(file_name, password)
            except FileNotFoundError:
                self.password = password
                self.write()
                seed_file_content = seed_file.decrypt_from_file(file_name, password)

            # If the incorrect key is given
            if seed_file_content == False:
                print(' - Incorrect Password, Try Again - ')
                # Loop to decrypt again
                continue
            # If the file is decrypted successfully, update the
            #  keyring password and break
            keyring_storage.set_keyring_password(password)
            self.password = password
            break
       
        # If the seed file has any seeds, add them to instance dict
        if seed_file_content:
            for key,value in seed_file_content.items():
                self[key] = value


    def __setitem__(self, key, value):
        if generators.verify_totp_seed(value):
            super().__setitem__(key, value)

    def __getitem__(self, key):
        if key not in self:
            raise KeyError('Key not found')

        return super().__getitem__(key)

    def write(self):
        '''
        Write current seed dictionary to encrypted file
        '''
        data = dict(self)
        seed_file.encrypt_to_file(data, self.file_name, self.password)


app = typer.Typer()
seed_dict = SeedDict()

@app.command()
def show(name: str) -> None:
    '''
    Show a single name and generated TOTP code

    Args:\n
        name (str): The name used to refence the seed phrase in the seed file
    '''
    if name in seed_dict:
        code = generators.get_totp_code(seed_dict[name])
        print(f"{name} - {code}")
    else:
        print(f"{name} not in seed file")

@app.command()
def show_all() -> None:
    '''
    Show all the names and generated TOTP codes
    '''
    if seed_dict:
        for name in seed_dict:
            show(name)

    else:
        print(" - Seed file is empty - ")

@app.command()
def show_seed(name: str) -> None:
    '''
    Show a seed phrase from your seed file

    Args:\n
        name (str): The name used to reference the seed phrase in the seed file
    '''
    if name in seed_dict:
        print(f"{name} - {seed_dict[name]}")
    else:
        print(f"{name} not in seed file")

@app.command()
def add(name: str, seed: str, force: bool=False) -> None:
    '''
    Add a new entry to your seed file

    Args:\n
        name (str): The name to reference your seed by
        \n
        seed (str): The TOTP seed phrase given by the application or service
        \n
        force (str): Forcibly change/update your entry's seed phrase
    '''
    if name in seed_dict and force == False:
        print(f"{name} already exists, pass '--force' to true to overwrite")
    else:
        seed_dict[name] = seed
        if seed_dict.get(name) == seed:
            show(name)
        else:
            print("Incorrect seed format")
        seed_dict.write()

@app.command()
def delete(name: str) -> None:
    '''
    Delete an entry from your seed file

    Args:\n
        name (str): The name of the entry
    '''
    if name in seed_dict:
        del seed_dict[name]
        seed_dict.write()

@app.command()
def export_seeds(encrypt: bool=True, file_name: str="") -> None:
    '''
    Export seed file content to a file or stdout in an encrypted or plain format

    Args:\n
        encrypt (bool, *optional):\n
            Whether to export the file as encrypted or plain
        \n
        file_name (str, *optional):\n
            The name of the file to export to. Output is directed to
            stdout if no file_name is provided.

    '''
    if not file_name:
        if encrypt:
            # print the seed files encrypted content to stdout with quit
            with open(seed_dict.file_name, 'r') as file:
                print(file.read())
                return
        # print the unencrypted seeds to stdout with quit
        print(json.dumps(seed_dict))    
        return
    
    if file_name:
        if encrypt:
            # Copy the seed files encrypted content to the export file
            shutil.copyfile(seed_dict.file_name, file_name)
            return
        # Write the un-encrypted seed dict to the file
        with open(file_name, 'w') as export_file: 
            json.dump(seed_dict, export_file)

@app.command()
def import_seeds(file_name: str) -> None:
    '''
    Import a previously exported file, overwriting the existing seeds

    Args:\n
        file_name (str):\n
            The previously exported file needs to either have a .aes or .json
            file suffix/extension.
    '''
    try:
        # Try loading as json
        try:
            # If plaintext, read in file content, create a new SeedDict instance
            #  which will encrypt the content to the mfa_secrets.aes file
            with open(file_name, 'r') as file:
                file_content = json.load(file)

            new_seed_dict = SeedDict()
            for name,seed in file_content.items():
                new_seed_dict[name] = seed
            new_seed_dict.write()

        # If the file doesn't contain valid json data
        except (AttributeError,json.decoder.JSONDecodeError):
            # If the file decrypts successfully
            if seed_file.decrypt_from_file(file_name, seed_dict.password):
                # Copy the encrypted file directly
                shutil.copyfile(file_name, seed_dict.file_name)
                return

            # If the file didn't decrypt correctly
            print(f"Either the incorrect password was used, or '{file_name}' is corrupt")

    except FileNotFoundError:
        print(f"'{file_name}' doesn't exists")
        quit(1)

@app.command()
def lock():
    '''
    Lock the seed file, AKA remove the password from the keyring
    '''
    keyring_storage.delete_keyring_password()

@app.command()
def auto_lock(minutes: str):
    '''
    Start a background script that locks the seed file, AKA removes the
    password from the keyring
    '''
    pass

if __name__=="__main__":
    app()
