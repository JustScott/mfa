#!/home/administrator/Git/Local/mfa/venv/bin/python
#
# mfa - part of the mfa project
# Copyright (C) 2023, Scott Wyman, development@scottwyman.me
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU Affero General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU Affero General Public License for more details.
#
# You should have received a copy of the GNU Affero General Public License
# along with this program.  If not, see <https://www.gnu.org/licenses/>.


import typer
import json
import generators
import keyring_storage
import seed_file
from seed_file import SeedDict
from getpass import getpass
import shutil
import os
import universal
import config
from pprint import pprint

__author__ = "Scott Wyman (development@scottwyman.me)"

__license__ = "GPLv3"

__date__ = "July 26, 2023"

__all__ = [""]

__doc__ = (
'''
A simple TOTP MFA CLI authenticator
'''
)


app = typer.Typer()
settings = config.Config(universal.CONFIG_FILE_PATH)


@app.command()
def show(name: str) -> None:
    '''
    Show a single name and generated TOTP code

    Args:\n
        name (str): The name used to refence the seed phrase in the seed file
    '''
    seed_dict = SeedDict()

    if name in seed_dict:
        code = generators.get_totp_code(seed_dict[name])
        print(f"{name} - {code}")
    else:
        print(f"{name} not in seed file")

@app.command()
def show_all() -> None:
    '''
    Show all the names and generated TOTP codes
    '''
    seed_dict = SeedDict()

    if seed_dict:
        for name in seed_dict:
            show(name)

    else:
        print(" - Seed file is empty - ")

@app.command()
def show_seed(name: str) -> None:
    '''
    Show a seed phrase from your seed file

    Args:\n
        name (str): The name used to reference the seed phrase in the seed file
    '''
    seed_dict = SeedDict()

    if name in seed_dict:
        print(f"{name} - {seed_dict[name]}")
    else:
        print(f"{name} not in seed file")

@app.command()
def add(name: str, seed: str, force: bool=False) -> None:
    '''
    Add a new entry to your seed file

    Args:\n
        name (str): The name to reference your seed by
        \n
        seed (str): The TOTP seed phrase given by the application or service
        \n
        force (str): Forcibly change/update your entry's seed phrase
    '''
    seed_dict = SeedDict()

    if name in seed_dict and force == False:
        print(f"{name} already exists, pass '--force' to true to overwrite")
    else:
        seed_dict[name] = seed
        if seed_dict.get(name) == seed:
            show(name)
        else:
            print("Incorrect seed format")
        seed_dict.write()

@app.command()
def delete(name: str) -> None:
    '''
    Delete an entry from your seed file

    Args:\n
        name (str): The name of the entry
    '''
    seed_dict = SeedDict()

    if name in seed_dict:
        del seed_dict[name]
        seed_dict.write()


@app.command()
def export_seeds(encrypt: bool=True, file_name: str="") -> None:
    '''
    Export seed file content to a file or stdout in an encrypted or plain format

    Args:\n
        encrypt (bool, *optional):\n
            Whether to export the file as encrypted or plain
        \n
        file_name (str, *optional):\n
            The name of the file to export to. Output is directed to
            stdout if no file_name is provided.

    '''
    if not file_name:
        if encrypt:
            # print the seed files encrypted content to stdout
            with open(SeedDict.SEED_FILE_PATH, 'r') as file:
                print(file.read())
                return
        # print the unencrypted seeds to stdout
        print(json.dumps(SeedDict()))    
        return
    
    if file_name:
        if encrypt:
            # Copy the seed files encrypted content to the export file
            shutil.copyfile(SeedDict.SEED_FILE_PATH, file_name)
            return
        # Write the un-encrypted seed dict to the file
        with open(file_name, 'w') as export_file: 
            json.dump(SeedDict(), export_file)

@app.command()
def import_seeds(file_path: str) -> None:
    '''
    Import a previously exported file, overwriting the existing seeds

    Args:\n
        file_path (str):\n
            The previously exported file needs to either have a .aes or .json
            file suffix/extension.
    '''
    seed_dict = SeedDict()

    try:
        # Try loading as json
        try:
            # If plaintext, read in file content, create a new SeedDict instance
            #  which will encrypt the content to the mfa_secrets.aes file
            with open(file_path, 'r') as file:
                file_content = json.load(file)

            new_seed_dict = SeedDict()
            for name,seed in file_content.items():
                new_seed_dict[name] = seed
            new_seed_dict.write()

        # If the file doesn't contain valid json data
        except (AttributeError,json.decoder.JSONDecodeError):
            # If the file decrypts successfully
            if seed_file.decrypt_from_file(file_path, seed_dict.password):
                # Copy the encrypted file directly
                shutil.copyfile(file_path, seed_dict.SEED_FILE_PATH)
                return

            # If the file didn't decrypt correctly
            print(f"Either the incorrect password was used, or '{file_path}' is corrupt")

    except FileNotFoundError:
        print(f"'{file_path}' doesn't exists")
        quit(1)


@app.command()
def lock():
    '''
    Lock the seed file, AKA remove the password from the keyring
    '''
    keyring_storage.delete_keyring_password()
    print("Seed file locked!")

@app.command()
def auto_lock(minutes: int):
    '''
    Lockout access to the seed file in x minute intervals

    Starts a background script that runs the lock command at user set intervals
    
    Args:\n
        minutes (int):
            Access to the MFA codes will be locked every time this number
            of minutes passes.

            Set minutes to zero to turn off the locking
    '''
    # If the user passes a zero or a negative number,
    #  set the config files auto_lock_interval to 0
    if minutes < 1:
        settings['auto_lock_interval'] = 0
        settings.write()
        print("Auto locking turned off")
        return

    # Start the auto_lock.py script if it's not already running
    if not universal.process_is_running('python3', 'auto_lock.py'):
        os.system(f'{universal.BASE_PATH}/venv/bin/python3 {universal.BASE_PATH}/auto_lock.py &')

    settings['auto_lock_interval'] = int(minutes)
    settings.write()
    print(f"Access to the MFA codes will be locked every {minutes} minute(s)")


@app.command()
def config_settings(
        seed_file_path: str=None, config_file_path: str=None, 
        auto_lock_interval: str=None
    ):
    '''
    Change any setting in the config file

    Args:\n
        seed-file-path (str, *optional): The encrypted seed file's new full path, not including the file name

        auto-lock-interval (int, *optional):\n 
            Minutes between automatic locking intervals. Set to zero to turn off.
    '''
    for setting,value in locals().items():
        # If the user changes auto_lock_interval, just pass the value
        # to the auto_lock function since it already has the logic to
        #  check and set the value
        if setting == 'auto_lock_interval' and value != None and value.isdigit():
            auto_lock(int(value))
        if setting == 'seed_file_path' and value:
            shutil.move(SeedDict.SEED_FILE_PATH, value)
            

        # Otherwise, if another value is passed, set it in the config file
        if value:
            settings[setting] = value

    settings.write()

@app.command()
def export_config(export_file_path: str=""):
    '''
    Export your json config settings to a file or stdout
    
    Args:
        export_file_path (str, *optional):
            The file to export your json config settings to, leave empty
            to print the json to stdout
    '''
    if export_file_path:
        shutil.copyfile(universal.CONFIG_FILE_PATH, export_file_path)
        return

    print(json.dumps(settings))

@app.command()
def import_config(file_path: str):
    '''
    Import a previously exported config file

    Args:
        file_path (str):
            The full path of the config file, including the file's name
    '''
    try:
        # Make sure the file is valid json
        with open(file_path, 'r') as config_file:
            json.load(config_file)

        # Overwrite the existing config file if it exists, with the user
        #  provided config file
        shutil.copyfile(file_path, universal.CONFIG_FILE_PATH)
        print("Import Successful!")
    except FileNotFoundError:
        print(f"Can't open the file '{file_path}'")
    except json.decoder.JSONDecodeError:
        print(f"'{file_path}' is not a valid MFA configuration file")


if __name__=="__main__":
    app()

    seed_dict = SeedDict()

    # If the auto lock is on in the config file and the auto_lock.py script isn't running
    if settings.get('auto_lock_interval') and not universal.process_is_running('python3', 'auto_lock.py'):
        # Turn on auto locking with the saved interval
        auto_lock(settings['auto_lock_interval'])


